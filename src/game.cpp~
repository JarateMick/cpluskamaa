#include "game.h"

#include <chrono>
#include <string>
#include <vector>
// #define EXE_COMPILE 1
#include <unordered_set>
#include "Random.cpp"
// #define _USE_MATH_DEFINES

#include <math.h>
#include <algorithm>
#include <lua.hpp>

#include <SDL2\SDL_image.h>

#undef max
#undef min

#define CLAMP(x, upper, lower) (std::min(upper, std::max(x, lower)))

using namespace std;

StackAllocator g_singleFrameAllocator;

// TODO: CROSS PLATFORM SAVING LOADING!!!
//void SaveAllEntitys(game_state* gameState, const char* fileName)
//{
//	ALLEGRO_FILE* file = nullptr;
//
//	file = al_fopen(fileName, "wb");
//	if (!file)
//	{
//		printf("couldn't not open file");
//		ASSERT(false);
//	}
//
//	for (auto &Entity : gameState->entities)
//	{
//		al_fwrite(file, &Entity, sizeof(Entity));
//	}
//	al_fclose(file);
//}
//
//void LoadAllEntity(game_state* gameState, const char* fileName)
//{
//	ALLEGRO_FILE* file = al_fopen(fileName, "rb");
//
//	int64_t nb_read_total = 0, nb_read = 1;
//
//	if (file)
//	{
//		al_fseek(file, 0, ALLEGRO_SEEK_END);
//		int64_t fileSize = al_ftell(file);
//		al_fseek(file, 0, ALLEGRO_SEEK_SET);
//
//		int index = 0;
//
//		while (nb_read_total < fileSize && nb_read != 0)
//		{
//			Entity entity;
//			nb_read = al_fread(file, &entity, sizeof(Entity));
//			nb_read_total += nb_read;
//
//			ASSERT(index < ArrayCount(gameState->entities));
//			gameState->entities[index++] = entity;
//		}
//		al_fclose(file);
//	}
//	else
//	{
//		printf("couldn't open file");
//	}
//	gameState->currentEntityCount = (int)((float)nb_read_total / (float)sizeof(Entity));
//}


Entity* GetFirstAvaibleEntity(game_state* state)
{
	ASSERT(state->currentEntityCount < ArrayCount(state->entities));
	return &state->entities[state->currentEntityCount++];
}

// pointer to pointer that nullifys other pointers 
// sounds too complicated
void RemoveEntity(int index, game_state* state)
{
#if 1
	state->entities[index].type = Entity_Invalid;
#else // meh
	state->currentEntityCount--;
	Entity* array = state->entities;
	memcpy(array + index, array + state->currentEntityCount, sizeof(Entity));
	(array + index)->guid = index;
#endif
	// state->entities[state->currentEntityCount] = 0;
}

// Game:
//   * Better selection for region select
//   * Risk style battle screen
//   *

// Engine:
//   * Hotloading variable tweak -> (from google sheets maybe?)
//   * Configs files
//   * Better solutions for -> . -> . 
//   * Take look on allegro shader stuff
//   *

//fseek(f, 0, SEEK_END);
// unsigned long filelen = ftell(f);
// fseek(f, 0, SEEK_SET);
//
// m_data = new unsigned char[filelen];
// fread(m_data, 1, filelen, f);
// fclose(f);

void SaveAllGameState(game_state* gameState)
{
	FILE* file = fopen("gameState0", "wb");
	if (file)
	{
		fwrite(gameState, sizeof(game_state), 1, file);
		fclose(file);
	}
}


//#include <Box2D/Box2D.h>
//struct Box
//{
//	Box()
//	{
//	}
//
//	b2Body* body = 0;
//	b2Fixture* fixture;
//	float w;
//	float h;
//	float rotation;
//
//	void init(b2World* world, float x, float y, float w, float h)
//	{
//		this->w = w;
//		this->h = h;
//		b2BodyDef bodyDef;
//		bodyDef.type = b2_dynamicBody;
//		bodyDef.position.Set(x, y);
//
//		body = world->CreateBody(&bodyDef);
//
//		b2PolygonShape boxShape;
//		boxShape.SetAsBox(w / 2.f, h / 2.f);
//
//		b2FixtureDef fixtureDef;
//		fixtureDef.shape = &boxShape;
//		fixtureDef.density = 1.0f;
//		fixtureDef.friction = 0.3f;
//		fixture = body->CreateFixture(&fixtureDef);
//
//		rotation = 0.f;
//	}
//
//	void Update(EngineCore* core, game_state* state)
//	{
//		rotation += 0.07 * core->deltaTime;
//		if (core->input->isKeyDown(SDL_SCANCODE_F))
//		{
//			body->ApplyForce({ 0.f, 120.0f }, { 0.f, 0.f }, true);
//		}
//	}
//
//	void Draw(EngineCore* core, game_state* state, ALLEGRO_BITMAP* bitmap)
//	{
//		auto position = body->GetPosition();
//		auto angle = body->GetAngle();
//		printf("body: %f\n", position.y);
//
//		float centerX = position.x - core->cameraX + w / 2.f;
//		float centerY = position.y - core->cameraY + h / 2.f;
//
//		position.x -= core->cameraX + w / 2.f;
//		position.y -= -core->cameraY + h / 2.f;
//
//		// state->cameraX = position.x;
//		// state->cameraY = position.y;
//		float realY = core->screenHeight - position.y;
//
//		printf("angle is %f or %f radians", angle, angle * (M_PI / 180.f));
//
//		// al_draw_filled_rectangle(position.x, realY, position.x + w, realY - h, al_map_rgb(0, 0, 0));
//		al_draw_rotated_bitmap(bitmap, w / 2.f, h / 2.f, position.x + w / 2.0f, realY - h / 2.0f, angle /** M_PI / 180.f */, 0);
//		// al_draw_scaled_rotated_bitmap(bitmap, centerX, centerY, position.x, realY, )
//	}
//};
//
//b2Vec2 gravity{ 0.0f, -9.81f };
//static b2World g_world(gravity);
//static Box g_boxy;
//static b2Body* g_ground;
//static float hh = 10.0f;
//static float ww = 1000.0f;


lua_State* L;
EXPORT void Loop(EngineCore* core)
{
	game_state *gameState = (game_state*)core->memory->permanentStorage;
	// core->cameraX = gameState->cameraX;
	// core->cameraY = gameState->cameraY;
	if (!core->memory->isInitialized)
	{
		gameState->arena.InitalizeArena(core->memory->permanentStorageSize - sizeof(game_state),
			(uint8_t *)core->memory->permanentStorage + sizeof(game_state));

		core->filewatcher.init();

		L = core->script.L;

		Debug::_Debugger = core->debugger; // hööh :-(

		// TODO: defaults some neat fileloading facilities would be cool
		gameState->cameraSpeed = 50.0f;

        // Initialize some npc's;

        
        
        
        
        
        // static float* floats;
    // floats = PushArray(&gameState->arena, 10000000, float);

		// box2D
		// ground
		// static b2BodyDef groundBodyDef;
		// groundBodyDef.type = b2_staticBody;
		// groundBodyDef.position.Set(ww / 2.f + 50.f, hh / 2.f);
		// static b2Body* groundBody = g_world.CreateBody(&groundBodyDef);
		// make the ground fixture
		// static b2PolygonShape groundBox;
		// groundBox.SetAsBox(ww / 2.f, hh / 2.f);
		// groundBody->CreateFixture(&groundBox, 0.0f);

            // g_boxy.init(&g_world, 500.f, 710.0f, 15.0f, 15.0f);
            // g_ground = groundBody;

		// b2BodyDef def;
		// def.position.Set(hh, 0.f);
		// def.type = b2_staticBody;
		// b2Body* b = g_world.CreateBody(&def);
		// b2PolygonShape gbox;
		// gbox.SetAsBox(4.f, 100.f);
		// b->CreateFixture(&gbox, 0.0f);

		// g_world.Dump();
		// g_world.set



		core->memory->isInitialized = true;

		gameState->entities[0].type = Entity_ninja;
		gameState->entities[1].type = Entity_npc;

		int j = 0;
		for (int i = 0; i < (int)ArrayCount(gameState->entities); i++)
		{
			gameState->entities[i].guid = i;
			j++;
		}
		gameState->currentEntityCount = 2;


        // init some npc's
        Entity* e = GetFirstAvaibleEntity(gameState);
        e->type = Entity_script;
        auto script = GET_ENTITY(e, script);
        sprintf(script->message, "%s", "Morjesta"); // Luassa olisi kiva maaritella jutut
        script->hitbox = { 0, 0, 40, 80 };




		if (!Debug::restartLog())
		{
			printf("log restart failed: %s, %d", __FILE__, __LINE__);
		}
	}

//for (int i = 0; i < 20; i++)
//{
//	for (int j = 0; j < 20; j++)
//	{
//		DrawRect(i * 30, j * 30, 20, 20);
//	}
//}
// Draw()



	// g_world.Step(core->deltaTime, 6, 2);

	/*************************************************/
	// ENTITY UPDATE
	for (int i = 0; i < gameState->currentEntityCount; i++)
	{
		f(&gameState->entities[i], core);
	}

	// TODO: Nuke this init phase
	static bool init = false;
	if (!init) // || core->input->isKeyPressed(SDL_SCANCODE_SPACE))
	{
		Random::init();


    init = true;
}

	// g_boxy.Update(core, gameState);

	// pelaajan kontrollit
	// TODO: Engine kamat engineen
	InputManager* input = core->input;

	if (input->isKeyPressed(SDL_SCANCODE_4))
	{
		SaveAllGameState(gameState);
	}

	static char *saveFile = "testailu.data";
	if (input->isKeyPressed(SDL_SCANCODE_1))
	{
		// SaveAllEntitys(gameState, "entity.sav");
	}
	else if (input->isKeyPressed(SDL_SCANCODE_2))
	{
		// LoadAllEntity(gameState, "entity.sav");
	}
}

// hex sizes --- world in meters
static const float hexWidth = 30.f;
static const float hexHeight = 35.f;
static const float halfHexW = hexWidth / 2.f;
static const float halfHexH = hexHeight / 2.f;
static const float hexInMeters = 1.f;
static const float hexInPixels = hexWidth;
static const float metersToPixel = hexInPixels / hexInMeters;
static const float HexHeightInMeter = hexHeight / hexWidth;

// #define hexWidth 30.f
// #define hexheigth 35.f

struct Entity2
{
	void Update(int a)
	{
		this->x = a;
		this->y = a;
	}
	void Printf(int message)
	{
		printf("hello from lua %d", message);
	}

        float x;
        float y;

	void Draw()
	{
		// static ALLEGRO_BITMAP* bmp = al_load_bitmap("test.png");
		// al_draw_bitmap(bmp, x, y, 0);
	}


	void SetPos(float x, float y)
	{
		this->x = x;
		this->y = y;
	}
};


game_state* state = 0;
static int ID = -1;
int CreateEntityHandle()
{
	Entity &e = state->entities[++ID];
	e.x = 0.f;
	e.y = 0.f;
	e.type = Entity_script;
	e.guid = ID;
	return ID;
}

void SetEntityPosition(float x, float y, int id)
{
	Entity* e = &state->entities[id];
	e->x = x;
	e->y = y;
}

void SetEntityVel(float velX, float velY, int id)
{
	state->entities[id].velX = velX;
	state->entities[id].velY = velY;
}

// poistossa synccaa molemmat swap and win !
// serialisoi     
// id -> entity formaattiin luan sisällä

//void SetAllEntitys()
//{
//	sol::table entity = (*luaP)["ents"]; // func
//	for (int i = 0; i < ID; i++)
//	{
//		Entity& e = state->entities[i];
//		e.x = entity[i]["x"] = e.x + e.velX;
//		e.y = entity[i]["y"] = e.y + e.velY;
//	}
//}

//void SetAllEntitys2(int count, const char* table)
//
//{
//	sol::table entity = (*luaP)[table]; // func
//	for (int i = 1; i < count; i++)
//	{
//		Entity& e = state->entities[i];
//		e.x = entity[i]["x"] = e.x + e.velX;
//		e.y = entity[i]["y"] = e.y + e.velY;
//	}
//}

EXPORT __declspec(dllexport) typedef struct
{
	float x;
	float y;
} v2;

EXPORT __declspec(dllexport) typedef struct
{
	int x;
	int y;
} v2i;

const char* entitySetFunctionName = "foo2";
EXPORT __declspec(dllexport) void Physics(v2* data, int count)
{
	// static ALLEGRO_BITMAP* bmp = al_load_bitmap("test.png");

	for (int i = 0; i < ID + 1; i++)
	{
		Entity& e = state->entities[i];
		data[i].x += e.velX;
		data[i].y += e.velY;
	}

	for (int i = 0; i < ID + 1; i++)
	{
		// al_draw_bitmap(bmp, data[i].x, data[i].y, 0);
	}
}

void SetAllEntitysPositions()
{
	// (*luaP)[entitySetFunctionName]();
}

void DrawAllEntitys(EngineCore* core)
{
	// static ALLEGRO_BITMAP* bmp = al_load_bitmap("test.png");

	// al_hold_bitmap_drawing(true);
	for (int i = 0; i < ID; i++)
	{
		Entity& e = state->entities[i];
		// al_draw_bitmap(bmp, e.x - core->cameraX, e.y - core->cameraY, 0);
	}
	// al_hold_bitmap_drawing(false);
}

//inline void my_panic(sol::optional<std::string> maybe_msg) {
//	// std::cerr << "Lua is in a panic state and will now abort() the application" << std::endl;
//	if (maybe_msg) {
//		const std::string& msg = maybe_msg.value();
//		// std::cerr << "\terror message: " << msg << std::endl;
//	}
//	// When this function exits, Lua will exhibit default behavior and abort()
//}

// struct Vector2
// {
	// float x, y;
// };

EXPORT __declspec(dllexport) void SyncData(v2* data, int count)
{
	for (int i = 0; i < count; i++)
	{
		v2* d = &data[i];
		d->x = 10000;
		d->y = 10000;
	}
}

EXPORT __declspec(dllexport) void Hello2(v2* data, int count)
{
	for (int i = 0; i < count; i++)
	{
		v2* d = &data[i];
		d->x = i;
		d->y = i;
	}
}

EXPORT __declspec(dllexport) void Dangerous(v2* data, int count)
{
}

EXPORT __declspec(dllexport) void EmptyFunc(double x, double y)
{

}

EXPORT __declspec(dllexport) int GetX(int id)
{
	return 1;
}
EXPORT __declspec(dllexport) int GetY(int id)
{
	return 2;
}

EXPORT __declspec(dllexport) void Swapper(float &x, float &y, int id)
{
	x = 10;
	y = 10;
}

EXPORT __declspec(dllexport) void Drawer(float x, float y)
{
	// static ALLEGRO_BITMAP* texture = al_load_bitmap("test.png");
	// al_draw_bitmap(texture, x, y, 0);
}

void Hello(void* vecs)
{
	// printf("tanne tuli %i!", vecs[0].x);
	// v2* v = (v2*)vecs;
	// printf("hei %i", v[1].x);
}


void LuaErrorWrapper(game_state* state, EngineCore* core)
{
	InputManager* input = core->input;



	//	int succ = luaL_loadfile(L, filename);
	lua_getglobal(L, "main_function");
	int ret = lua_pcall(L, 0, 0, 0);
	if (ret != 0)
	{
		fprintf(stderr, "%s\n", lua_tostring(L, -1));
		debugBreak();
	}
	lua_settop(L, 0);

	//if (!init1)
	//{
	//	core->script.luaP = &lua;
	//	lua.open_libraries(sol::lib::base, sol::lib::os, sol::lib::string, sol::lib::math, sol::lib::ffi,
	//		sol::lib::package, sol::lib::jit, sol::lib::table);
	//	lua["Draw"] = DrawRect2;
	//	lua["HoldBitmap"] = al_hold_bitmap_drawing;
	//	init1 = true;

	//	// lua["outoStruct"] = &Hello;
	//	// lua["e2"] = e2;
	//	// lua["Update"] = &Entity2::Update;
	//	// lua["DrawLots"] = &DrawLotsOfEntitys;
	//	// lua["DrawUpdate"] = &DrawUpdateEntity;
	//	// void SetAllEntitys2(int count, const char* table)
	//	// lua["SetAllEntity2"] = &SetAllEntitys2;
	//	//usertype<Entity2> Entity2Type(
	//	//	"Update", &Entity2::Update,
	//	//	"Printf", &Entity2::Printf
	//	//);
	//	//lua.set_usertype<Entity2>("Entity2", Entity2Type);
	//	// lua.set("DrawUpdate2", sol::c_call<sol::wrap<decltype(&DrawUpdateEntity), &DrawUpdateEntity>>);
	//	//lua.new_usertype<Entity2>("Entity2",
	//	//	"Update", &Entity2::Update,
	//	//	"Printf", &Entity2::Printf,
	//	//	"x", &Entity2::x,
	//	//	"y", &Entity2::y,
	//	//	"SetPos", &Entity2::SetPos,
	//	//	"Draw", &Entity2::Draw
	//	//	);
	//	// lua.script("ents = {}");
	//	lua["SetEntityPos"] = &SetEntityPosition;
	//	lua["SetEntityVel"] = &SetEntityVel;
	//	lua["CreateEntityHandle"] = &CreateEntityHandle;
	//	// lua["input"] = sol::table;
	//	lua.create_named_table("Input");
	//	lua["Input"]["mouse"] = lua.create_table_with();
	//	lua.create_named_table("time");

	//	lua["PhysAndDraw"] = &Physics;

	//	luaP = &lua;
	//}

	//(*luaP)["Input"]["mouse"]["x"] = input->mouseX;
	//(*luaP)["Input"]["mouse"]["y"] = input->mouseY;

	//(*luaP)["Input"]["w"] = input->isKeyDown(SDL_SCANCODE_W);
	//(*luaP)["Input"]["s"] = input->isKeyDown(SDL_SCANCODE_S);
	//(*luaP)["Input"]["d"] = input->isKeyDown(SDL_SCANCODE_D);
	//(*luaP)["Input"]["a"] = input->isKeyDown(SDL_SCANCODE_A);
	//(*luaP)["time"]["dt"] = core->deltaTime;

	//al_hold_bitmap_drawing(true);

	//try
	//{
	//	lua.safe_script_file("I:/Dev/Allegro/allegro/bin/lua/main2.lua");
	//}
	//catch (sol::error& err)
	//{
	//	printf("sol::error: %s", err.what());
	//	// render
	//	static ALLEGRO_FONT* font = al_load_ttf_font("rs.ttf", 30, 0);
	//	al_draw_text(font, al_map_rgb(255, 120, 120), 40, 40, 0, err.what());

	//	// al_flip_display();

	//	// core->forceFlip();

	//	DebugBreak();
	//}
	//catch (...)
	//{
	//	DebugBreak();
	//}

	//al_hold_bitmap_drawing(false);
}

// struct v2
// {
	// float x, y;
// };

// struct Rect
// {
	// int x, y, w, h;
// };

static int TileWidth = 64;
static int TileHeight = 64;

static int TileStepX = 64;
static int TileStepY = 16;

static int OddRowXOffset = 32;
static int OddRowYOffset = 32;
static int HeightTileOffset = 32;

static int squaresAcross = 17;
static int squaresDown = 37;
static int baseOffsetX = -32;
static int baseOffsetY = -64;
static float heightRowDepthMod = 0.00001f;

static int mapWidth = 50;
static int mapHeight = 50;

static v2 originPoint{ 19, 39 };

class MapCell // TODO(Smartz): preallokoisusta
{
public:
	std::vector<int> baseTiles;
	std::vector<int> heightTiles;
	std::vector<int> topperTiles;


	// TODO: Enums
	int TileID;
	int slopeMap = -1;
	bool walkable = true;

	void AddBaseTile(int tileID)
	{
		baseTiles.push_back(tileID);
	}

	void AddHeightTile(int tileID)
	{
		heightTiles.push_back(tileID);
	}

	void AddTopperTile(int tileID)
	{
		topperTiles.push_back(tileID);
	}


	MapCell(int tileID) : TileID(tileID)
	{
		baseTiles.push_back(TileID);
		slopeMap = -1;
	}

	MapCell(int tileID, bool walkable) : TileID(tileID), walkable(walkable)
	{
		baseTiles.push_back(TileID);
	}

	MapCell() = default;
};

// some surface pixel manipulation helpers
Uint32 get_pixel32(SDL_Surface *surface, int x, int y)
{
	Uint32 *pixels = (Uint32 *)surface->pixels;
	return pixels[(y * surface->w) + x];
}

void put_pixel32(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
	Uint32 *pixels = (Uint32 *)surface->pixels;
	pixels[(y * surface->w) + x] = pixel;
}



v2i WorldCoordinateToMapCell(const glm::vec2& hilightLocation)
{
	static SDL_Surface* surface = IMG_Load("mousemap.png");

	if (surface)
	{
		static bool init = false;
		if (!init)
		{
			SDL_LockSurface(surface);
			init = true;
		}

		v2i mapCell = { (int)(hilightLocation.x / surface->w), (int)(hilightLocation.y / surface->h) * 2 };

		int localPointX = (int)hilightLocation.x % surface->w;
		int localPointY = (int)hilightLocation.y % surface->h;
		int dx = 0;
		int dy = 0;

            // if ( ) POINT CONTAINS

		Uint32 pixel = get_pixel32(surface, localPointX, localPointY);

		if (pixel == 0xFF0000FF) // red
		{
			dx = -1;
			dy = -1;
			localPointX = localPointX + (surface->w / 2);
			localPointY = localPointY + (surface->h / 2);
		}
		if (pixel == 0xFF00FF00) // Green
		{
			dx = -1;
			dy = 1;
			localPointX += surface->w / 2;
			localPointY -= surface->h / 2;
		}
		if (pixel == 0xFF00FFFF) // Yellow
		{
			dy = -1;
			localPointX -= surface->w / 2;
			localPointY += surface->h / 2;
		}
		if (pixel == 0xFFFF0000) // Bluw
		{
			dy = 1;
			localPointX -= surface->w / 2;
			localPointY -= surface->h / 2;
		}
		mapCell.x += dx;
		mapCell.y += dy; // -2;

		// SDL_UnlockSurface(surface);
		// printf("x: %i, %i\n", mapCell.x, mapCell.y);

		return mapCell;
		// v2 veccs((int)hilightLocation.x /  )
	}
	else
	{
		Debug::logError("mousemap.png not found!");
		ASSERT(false);
	}

	return { -1, -1 };
}

v2i WorldCoordinateToMapCell(const glm::vec2& hilightLocation, glm::vec2* outLocalPoint)
{
	static SDL_Surface* surface = IMG_Load("mousemap.png");

	if (surface)
	{	
		static bool init = false;

		if (!init)
		{
			SDL_LockSurface(surface);
			init = true;
		}

		v2i mapCell = { (int)(hilightLocation.x / surface->w), (int)(hilightLocation.y / surface->h) * 2 };

		int localPointX = (int)hilightLocation.x % surface->w;
		int localPointY = (int)hilightLocation.y % surface->h;
		int dx = 0;
		int dy = 0;


		// if ( ) POINT CONTAINS

		Uint32 pixel = get_pixel32(surface, localPointX, localPointY);

		if (pixel == 0xFF0000FF) // red
		{
			dx = -1;
			dy = -1;
			localPointX = localPointX + (surface->w / 2);
			localPointY = localPointY + (surface->h / 2);
		}
		if (pixel == 0xFF00FF00) // Green
		{
			dx = -1;
			dy = 1;
			localPointX += surface->w / 2;
			localPointY -= surface->h / 2;
		}
		if (pixel == 0xFF00FFFF) // Yellow
		{
			dy = -1;
			localPointX -= surface->w / 2;
			localPointY += surface->h / 2;
		}
		if (pixel == 0xFFFF0000) // Bluw
		{
			dy = 1;
			localPointX -= surface->w / 2;
			localPointY -= surface->h / 2;
		}
		mapCell.x += dx;
		mapCell.y += dy; // -2;

		outLocalPoint->x = localPointX;
		outLocalPoint->y = localPointY;

		// SDL_UnlockSurface(surface);
		// printf("x: %i, %i\n", mapCell.x, mapCell.y);

		return mapCell;
		// v2 veccs((int)hilightLocation.x /  )
	}
	else
	{
		Debug::logError("mousemap.png not found!");
		ASSERT(false);
	}

	return { -1, -1 };
}


class TileMap
{
public:
	int MapWidth = 50;
	int MapHeigth = 50;
#define GetTile(x, y) tiles[(y) * MapWidth + (x)]

	MapCell tiles[50 * 50];

	SDL_Surface* slopeMap = 0;
	SDL_Surface* mouseMap = 0;

	TileMap()
	{
		slopeMap = IMG_Load("slopemap.png");
		mouseMap = IMG_Load("mousemap.png");

		SDL_LockSurface(slopeMap);
		SDL_LockSurface(mouseMap);

		for (int y = 0; y < MapHeigth; y++)
		{
			for (int x = 0; x < MapWidth; x++)
			{
				tiles[y * MapWidth + x] = MapCell(0);
			}
		}

		GetTile(16, 4).AddHeightTile(54);
		GetTile(17, 3).AddHeightTile(54);
		GetTile(15, 3).AddHeightTile(54);

		GetTile(16, 3).AddHeightTile(53);

		GetTile(15, 4).AddHeightTile(54);
		GetTile(15, 4).AddHeightTile(54);

		GetTile(15, 4).AddHeightTile(51);
		GetTile(18, 3).AddHeightTile(51);
		GetTile(19, 3).AddHeightTile(50);
		GetTile(18, 4).AddHeightTile(55);

		GetTile(14, 4).AddHeightTile(54);
		GetTile(14, 5).AddHeightTile(62);
		GetTile(14, 5).AddHeightTile(61);
		GetTile(14, 5).AddHeightTile(63);

		GetTile(17, 4).AddTopperTile(114);
		GetTile(16, 5).AddTopperTile(115);
		GetTile(14, 4).AddTopperTile(125);
		GetTile(15, 5).AddTopperTile(91);
		GetTile(16, 6).AddTopperTile(94);


		GetTile(3, 3).AddHeightTile(54);

		GetTile(7, 7).AddHeightTile(54);
		GetTile(7, 7).AddHeightTile(54);
		GetTile(8, 7).AddHeightTile(54);
		GetTile(8, 7).AddHeightTile(54); // alimmat

		GetTile(6, 8).AddHeightTile(54); // ???
		GetTile(6, 8).AddHeightTile(54);
		GetTile(6, 7).AddHeightTile(54);
		GetTile(6, 7).AddHeightTile(54);

		GetTile(6, 6).AddTopperTile(91); // joki
		GetTile(7, 5).AddTopperTile(94);

		GetTile(8, 4).AddTopperTile(91);
		GetTile(9, 3).AddTopperTile(114);
		GetTile(10, 3).AddTopperTile(114);


		GetTile(30, 15).AddHeightTile(54); //
		GetTile(30, 15).AddHeightTile(54); //
		GetTile(30, 15).AddTopperTile(114); //


		GetTile(31, 15).AddHeightTile(54); //
		GetTile(31, 15).AddHeightTile(54); //
		GetTile(31, 15).AddTopperTile(91); // 


		GetTile(30, 16).AddHeightTile(54); //
		GetTile(30, 16).AddHeightTile(54); //
		GetTile(30, 16).AddTopperTile(114); //


		GetTile(29, 15).AddHeightTile(54); //
		GetTile(29, 15).AddHeightTile(54); //
		GetTile(29, 15).AddTopperTile(114); //
		// SetTile(31, 15).AddHeightTile(54); //
		// SetTile(31, 15).AddHeightTile(54); //
		// SetTile(31, 15).AddTopperTile(114); //



		// ylä-vasen talo:
		GetTile(2, 44).AddHeightTile(54);
		GetTile(2, 44).AddHeightTile(54);
		GetTile(2, 44).AddTopperTile(114);

		GetTile(2, 45).AddHeightTile(54);
		GetTile(2, 45).AddHeightTile(54);
		GetTile(2, 45).AddTopperTile(114);

		GetTile(3, 44).AddHeightTile(54);
		GetTile(3, 44).AddHeightTile(54);
		GetTile(3, 44).AddTopperTile(114);

		GetTile(2, 43).AddHeightTile(54);
		GetTile(2, 43).AddHeightTile(54);
		GetTile(2, 43).AddTopperTile(114);

		// another brick in the wall
		GetTile(3, 42).walkable = false;
		GetTile(3, 42).AddHeightTile(54);

		GetTile(3, 41).walkable = false;
		GetTile(3, 41).AddHeightTile(54);

		GetTile(4, 40).walkable = false;
		GetTile(4, 40).AddHeightTile(54);

		GetTile(4, 39).walkable = false;
		GetTile(4, 39).AddHeightTile(54);

		// A hill to climb!
		GetTile(11, 10).AddHeightTile(34);
		GetTile(11, 9).AddHeightTile(34);
		GetTile(11, 8).AddHeightTile(34);
		GetTile(10, 9).AddHeightTile(34);

		GetTile(10, 8).AddTopperTile(31);
		GetTile(10, 8).slopeMap = 0;
		GetTile(10, 7).AddTopperTile(31);
		GetTile(10, 7).slopeMap = 0;

		GetTile(11, 7).AddTopperTile(32);
		GetTile(11, 7).slopeMap = 1;
		GetTile(12, 8).AddTopperTile(32);
		GetTile(12, 8).slopeMap = 1;

		GetTile(11, 6).AddTopperTile(30);
		GetTile(11, 6).slopeMap = 4;
	}

	int GetSlopeMapHeight(glm::vec2 localPixel, int slopeMap)
	{
		// HUOMI: slope tekstuuri on 'väärin päin'
		v2i texturePoint{ (int)(slopeMap * mouseMap->w + localPixel.x), this->slopeMap->h - (int)localPixel.y }; 

		// TODO: bounds checking
		// jos rect containaa
		Uint32 pixelColor2 = get_pixel32(this->slopeMap, 95, 13);

		if (true)
		{
			Uint32 pixelColor = get_pixel32(this->slopeMap, texturePoint.x, texturePoint.y);
			
			int offset = (int)(((255 - (pixelColor & (0xFF))) / 255.f) * HeightTileOffset);
			return offset;
		}

		return 0;
	}			

	int GetSlopeHeightAtWorldPoint(glm::vec2 worldPoint)
	{
		glm::vec2 localPoint;
		auto mapPoint = WorldCoordinateToMapCell(worldPoint, &localPoint);

		int slopeMap = GetTile(mapPoint.x, mapPoint.y).slopeMap;

		if (slopeMap == -1) return 0;
		return GetSlopeMapHeight(localPoint, slopeMap);
	}

	// slope height and tile height combined!
	int GetOverallHeight(glm::vec2 worldPoint)
	{
		auto mapCellPoint = WorldCoordinateToMapCell(worldPoint);
		int height = GetTile(mapCellPoint.x, mapCellPoint.y).heightTiles.size() * HeightTileOffset;
		height += GetSlopeHeightAtWorldPoint(worldPoint);

		return height;
	}

	MapCell GetMapCell(int x, int y)
	{
		return GetTile(x, y);
	}

	MapCell GetMapCell(glm::vec2 worldPoint)
	{
		auto vec2 = WorldCoordinateToMapCell(worldPoint);
		return GetTile(vec2.x, vec2.y);
	}


};

EXPORT void Draw(EngineCore* core)
{
	game_state *gameState = (game_state*)core->memory->permanentStorage;
	state = gameState;
	// al_set_target_bitmap(core->backBuffer);
	//aSDL_GL_MakeCurrent(core->window, *core->glcontext);

	InputManager* input = core->input;

	static bool initted2 = false;
	static TileMap tileMap; // to gamestate!

	// TODO: Free camera from main
	float cameraSpeed = gameState->cameraSpeed * core->deltaTime; // ei toimi samalla tavalla kuin updaten mov
	if (input->isKeyDown(SDL_SCANCODE_W))
	{
		core->camera2D->setPosition(core->camera2D->getPosition() + glm::vec2{ 0, cameraSpeed });
	}
	if (input->isKeyDown(SDL_SCANCODE_S))
	{
		core->camera2D->setPosition(core->camera2D->getPosition() + glm::vec2{ 0, -cameraSpeed });
	}
	if (input->isKeyDown(SDL_SCANCODE_A))
	{
		core->camera2D->setPosition(core->camera2D->getPosition() + glm::vec2{ -cameraSpeed, 0 });
	}
	if (input->isKeyDown(SDL_SCANCODE_D))
	{
		core->camera2D->setPosition(core->camera2D->getPosition() + glm::vec2{ cameraSpeed, 0 });
	}

	float cx = 0; //core->cameraX;
	float cy = 0; // core->cameraY;

	v2 firstSquare{ float(((int)cx) / TileStepX), float((int)cy / TileStepY) };
	int firstX = (int)firstSquare.x;
	int firstY = (int)firstSquare.y;

	v2 squareOffset{ float(((int)cy) % TileStepX), float((int)cy % TileStepY) };
	int offsetX = (int)squareOffset.x;
	int offsetY = (int)squareOffset.y;

	// mapwidht  mapheight  tilewidth
	float maxdepth = ((mapWidth + 1) + ((mapHeight + 1) * TileWidth) * 10);
	float depthOffset;

	glm::vec4 posAndSize(100, 100, 600, 600);
	// glm::vec4 uv(0.0f, 0.0f, 1.0f, 1.0f);
	// core->spriteBatch->draw(posAndSize, uv, 2, 1.0f, UpiEngine::ColorRGBA8(255, 255, 255, 255));


	for (int y = 0; y < mapHeight; y++)
	{
		int rowOffset = 0;
		if (y % 2 == 1) // firstY
			rowOffset = OddRowXOffset;

		for (int x = 0; x < mapWidth; x++)
		{
			// int mapx = firstX + x;
			// int mapy = firstY + y;   //mapx + mapy
			depthOffset = 0.7f + ((x + (y * TileWidth)) / maxdepth);

			// draw base tiles
			for (int i = 0; i < tileMap.tiles[mapWidth * y + x].baseTiles.size(); i++)
			{
				int tileID = tileMap.tiles[mapWidth * y + x].baseTiles[i];
				glm::vec4 uv = core->testyTexture->getUVs(tileID);

				static UpiEngine::ColorRGBA8 colorr(255, 255, 255, 255);

				glm::vec4 posandsize{
					x * TileStepX + rowOffset,
					y * TileStepY,
					TileWidth, TileHeight };

				core->spriteBatch->draw(posandsize, uv, core->testyTexture->texture.id, 1.0f, colorr);
			}
			int heighRow = 0;

			// draw HeightTIles
			for (int i = 0; i < tileMap.tiles[mapWidth * y + x].heightTiles.size(); i++)
			{
				int tileID = tileMap.tiles[mapWidth * y + x].heightTiles[i];
				glm::vec4 uv = core->testyTexture->getUVs(tileID);
				glm::vec4 posandsize{
					(x * TileStepX) + rowOffset,
					(y * TileStepY) + (heighRow * HeightTileOffset),
					TileWidth, TileHeight };

				static UpiEngine::ColorRGBA8 colorr(255, 255, 255, 255);
				core->spriteBatch->draw(posandsize, uv, core->testyTexture->texture.id,
					depthOffset - ((float)heighRow * heightRowDepthMod), colorr);
				heighRow++;
			}

			// draw toppertiles
			for (int i = 0; i < tileMap.tiles[mapWidth * y + x].topperTiles.size(); i++)
			{
				int tileID = tileMap.tiles[mapWidth * y + x].topperTiles[i];

				glm::vec4 uv = core->testyTexture->getUVs(tileID);

				glm::vec4 posandsize{
					(x * TileStepX) + rowOffset,
					(y * TileStepY) + (heighRow * HeightTileOffset),
					TileWidth, TileHeight };

				static UpiEngine::ColorRGBA8 colorr(255, 255, 255, 255);
				core->spriteBatch->draw(posandsize, uv, core->testyTexture->texture.id,
					depthOffset - ((float)heighRow * heightRowDepthMod), colorr);
			}

			// depthOffset - ((float)heightRow * heightRowDepthMod));
		}
	}

	// DRAW MOUSE POINTER ON SCREEN!!!
	glm::vec2 hilightLocation = core->camera2D->convertScreenToWorld({ core->input->mouseX, core->input->mouseY });

	static int iCounter = 0;
	iCounter++;

	static v2i mapCell = { 0, 0 }; // { (int)(hilightLocation.x / surface->w), (int)(hilightLocation.y / surface->h) * 2 };
	if (iCounter % 10 == 0)
	{
		mapCell = WorldCoordinateToMapCell(hilightLocation);
	}

	int hilightrosoffset = 0;
	if (((int)mapCell.y % 2) == 1)
	{
		hilightrosoffset = OddRowXOffset;
	}

	Debug::drawTextf(1, "mouse (%i, %i)", mapCell.x, mapCell.y);

	glm::vec4 uv = core->testyTexture->getUVs(0);
	glm::vec4 posandsize{
					(mapCell.x * TileStepX) + hilightrosoffset,
					(mapCell.y) * TileStepY,
					TileWidth, TileHeight };
	static UpiEngine::ColorRGBA8 colorr(120, 120, 120, 120);
	core->spriteBatch->draw(posandsize, uv, core->testyTexture->texture.id, 0.0f, colorr);


	// player ********************************************************************************
	static glm::vec4 playerPosAndSize = { 100.f, 100.f, 8.f, 16.f };
	glm::vec2 playerMoveVev{ 0.f, 0.f };
	if (input->isKeyDown(SDL_SCANCODE_DOWN))
	{
		playerMoveVev.y -= 1.f;
	}
	if (input->isKeyDown(SDL_SCANCODE_UP))
	{
		playerMoveVev.y += 1.f;
	}
	if (input->isKeyDown(SDL_SCANCODE_LEFT))
	{
		playerMoveVev.x -= 1.f;
	}
	if (input->isKeyDown(SDL_SCANCODE_RIGHT))
	{
		playerMoveVev.x += 1.f;
	}

	if (!tileMap.GetMapCell(glm::vec2{ playerPosAndSize.x + playerMoveVev.x, playerPosAndSize.y + playerMoveVev.y }).walkable)
	{
		playerMoveVev = { 0.f, 0.f };
	}
	playerPosAndSize.x = CLAMP(playerPosAndSize.x + playerMoveVev.x * 0.2f, (float)(TileWidth * tileMap.MapWidth), 0.f);
	playerPosAndSize.y = CLAMP(playerPosAndSize.y + playerMoveVev.y * 0.2f, (float)(TileWidth * tileMap.MapWidth), 0.f);

	static GLint playerId = 3; // UpiEngine::ResourceManager::getTexture("test.png").id;
	glm::vec4 uv22{ 0.0f, 0.0f, 1.0f, 1.0f };
	static UpiEngine::ColorRGBA8 playerColor(255, 255, 255, 255);

        glm::vec2 poss{ playerPosAndSize.x, playerPosAndSize.y };
        v2i vladStandingOn = WorldCoordinateToMapCell(poss);

	static UpiEngine::ColorRGBA8 white(255, 255, 255, 255);
	Debug::drawBox(glm::vec4{ vladStandingOn.x * TileStepX, vladStandingOn.y * TileStepY, 64, 64 }, white, 0.f);
	Debug::drawBox(glm::vec4{ poss.x, poss.y, 2.f, 2.f }, white, 0.f);

	// int playerHeight = tileMap.tiles[vladStandingOn.y * tileMap.MapWidth + vladStandingOn.x].heightTiles.size() * HeightTileOffset;

	int playerHeight = tileMap.GetOverallHeight(poss);
	glm::vec4 real = playerPosAndSize;
	real.y += playerHeight; // standing on the hill !


	// depth calculation is hard *********************************************************************************
	float playerDepth = 0.7f + ((vladStandingOn.x + (vladStandingOn.y * TileWidth)) / maxdepth);

	playerDepth -= ((float)tileMap.tiles[vladStandingOn.y * tileMap.MapWidth + vladStandingOn.x].heightTiles.size() * heightRowDepthMod);
	core->spriteBatch->draw(real, uv22, playerId, playerDepth, playerColor);
	// ***********************************************************************************************************

	Debug::drawTextf(2, "coords (%i, %i, %i)", vladStandingOn.x, vladStandingOn.y, 1);
	Debug::drawTextf(3, "player h: %i", playerHeight);


    if (core->input->isMouseClicked(0)) {
       // check if mouse pressed ???
       for (int i = 0; i < gameState->currentEntityCount; i++) {
            Entity& e = gameState->entities[i];
            if (e.type == Entity_script)
            {
                if (core->input->mouseX > e.x && core->input->mouseX < e.x &&
                    core->input->mouseY > e.y && core->input->mouseY < e.y )
                {
                    auto script = GET_ENTITY(&e, script);
                    
                    if (script->hitbox.Contains(core->input->mouseX, core->input->mouseY)) {
                        // hitbox clicked! show message
                        printf("hitbox clicked!");
                    }
                }
            }
       }
    }


    

    DrawAllEntitys(core);


    // tervesi; eetultat <><><>{}{}{}{}{}[][][][][
    // TODO: Fontit resource managerille
}

